

## Caesar Cipher - Phần 2: Xây dựng hàm giải mã và tối ưu code

### Mục tiêu phần 2

Hoàn thiện chương trình Caesar Cipher với ba nhiệm vụ:

- Xây dựng hàm giải mã (decrypt)
- Kết hợp hai hàm encrypt và decrypt thành một
- Tối ưu output message dựa trên chế độ hoạt động


### Logic giải mã (Decoding)

**Nguyên lý:**
Giải mã là quá trình ngược lại với mã hóa - dịch chuyển ngược về phía trước trong bảng chữ cái.

**Ví dụ minh họa:**

- Chữ mã hóa: G
- Shift number: 3
- Giải mã: G → F → E → D
- Kết quả: D (chữ gốc)


### Xây dựng hàm decrypt()

**Bước 1: Định nghĩa hàm**

```python
def decrypt(original_text, shift_amount):
    output_text = ""
    
    for letter in original_text:
        # Tìm vị trí hiện tại
        position = alphabet.index(letter)
        
        # Dịch chuyển NGƯỢC LẠI (trừ thay vì cộng)
        shifted_position = position - shift_amount
        
        # Sử dụng modulo để xử lý vượt biên
        shifted_position %= len(alphabet)
        
        # Lấy chữ cái mới
        new_letter = alphabet[shifted_position]
        
        # Thêm vào kết quả
        output_text += new_letter
    
    print(f"Here is the decoded result: {output_text}")
```

**So sánh encrypt vs decrypt:**


| Tiêu chí | Encrypt | Decrypt |
| :-- | :-- | :-- |
| Hướng shift | Cộng (+) | Trừ (-) |
| Công thức | `position + shift_amount` | `position - shift_amount` |
| Ví dụ | A + 3 = D | D - 3 = A |

### Test hàm decrypt

**Test case:**

```python
# Gọi hàm
decrypt(original_text=text, shift_amount=shift)

# Input
# Letter: a
# Shift: 2

# Logic
# Vị trí 'a': 0
# 0 - 2 = -2
# -2 % 26 = 24
# alphabet[24] = 'y'

# Output: y
```

**Giải thích modulo với số âm:**

- Khi `position - shift_amount` ra số âm
- Modulo tự động "quay vòng" về cuối bảng chữ cái
- Ví dụ: -2 % 26 = 24 (tương đương Z, Y)


### Kết hợp hai hàm thành một

**Vấn đề:** Code bị lặp lại (repetitive) giữa encrypt và decrypt

**Giải pháp:** Tạo hàm `caesar()` tổng quát xử lý cả hai chức năng

### Phân tích điểm khác biệt

Duy nhất một dòng code khác nhau:

```python
# Encrypt
shifted_position = position + shift_amount

# Decrypt  
shifted_position = position - shift_amount
```


### Kỹ thuật toán học: Đảo dấu với -1

**Công thức:**

- Số dương × (-1) = Số âm
- Số âm × (-1) = Số dương
- Cộng số âm = Trừ số dương

**Ví dụ:**

```python
# Encode: shift_amount = 3
# shifted_position = position + 3

# Decode: shift_amount = 3
# shift_amount *= -1  # Biến thành -3
# shifted_position = position + (-3)  # Tương đương position - 3
```


### Xây dựng hàm caesar()

```python
def caesar(original_text, shift_amount, encode_or_decode):
    output_text = ""
    
    # Nếu decode, đảo dấu shift_amount
    if encode_or_decode == "decode":
        shift_amount *= -1
    
    for letter in original_text:
        position = alphabet.index(letter)
        
        # Cùng một công thức cho cả encode và decode
        shifted_position = position + shift_amount
        shifted_position %= len(alphabet)
        
        new_letter = alphabet[shifted_position]
        output_text += new_letter
    
    print(f"Here is the {encode_or_decode}d result: {output_text}")
```

**Giải thích logic:**

**Trường hợp 1 - Encode:**

- `encode_or_decode = "encode"`
- If statement KHÔNG thực thi
- `shift_amount` giữ nguyên (dương)
- `position + shift_amount` → dịch chuyển về sau

**Trường hợp 2 - Decode:**

- `encode_or_decode = "decode"`
- If statement thực thi
- `shift_amount *= -1` → biến thành số âm
- `position + (-shift_amount)` → tương đương trừ → dịch chuyển về trước


### Gọi hàm caesar()

```python
# Cách 1: Positional arguments
caesar(text, shift, direction)

# Cách 2: Keyword arguments (rõ ràng hơn)
caesar(
    original_text=text,
    shift_amount=shift,
    encode_or_decode=direction
)
```


### Xử lý tên biến trùng lặp (Shadowing)

**Vấn đề:**

```python
# Biến global
direction = input("Type 'encode' or 'decode':\n")

# Tham số hàm cùng tên → Warning
def caesar(original_text, shift_amount, direction):
    pass
```

**Cảnh báo IDE:** "Shadows name 'direction' from outer scope"

**Giải pháp:** Đổi tên tham số để tránh nhầm lẫn

```python
# Tốt hơn
def caesar(original_text, shift_amount, encode_or_decode):
    pass
```


### Tối ưu output message

**Vấn đề:** Output luôn hiển thị "encoded result" cho cả encode và decode

**Giải pháp thông minh:** Sử dụng f-string kết hợp với biến

```python
# Trước
print(f"Here is the encoded result: {output_text}")

# Sau
print(f"Here is the {encode_or_decode}d result: {output_text}")
```

**Cách hoạt động:**

- `encode + d` → "encoded result"
- `decode + d` → "decoded result"
- Tận dụng quy tắc ngữ pháp tiếng Anh (past tense)


### Code hoàn chỉnh sau tối ưu

```python
alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 
            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

direction = input("Type 'encode' to encrypt, type 'decode' to decrypt:\n")
text = input("Type your message:\n").lower()
shift = int(input("Type the shift number:\n"))

def caesar(original_text, shift_amount, encode_or_decode):
    output_text = ""
    
    if encode_or_decode == "decode":
        shift_amount *= -1
    
    for letter in original_text:
        position = alphabet.index(letter)
        shifted_position = (position + shift_amount) % len(alphabet)
        output_text += alphabet[shifted_position]
    
    print(f"Here is the {encode_or_decode}d result: {output_text}")

# Gọi hàm
caesar(original_text=text, shift_amount=shift, encode_or_decode=direction)
```


### Test chương trình

**Test 1 - Encode:**

```
Input: encode
Message: a
Shift: 2
Output: Here is the encoded result: c
```

**Test 2 - Decode:**

```
Input: decode
Message: a  
Shift: 2
Output: Here is the decoded result: y
```


### Nguyên tắc kỹ thuật quan trọng

**DRY Principle (Don't Repeat Yourself):**

- Tránh copy-paste code giống nhau
- Tìm cách tổng quát hóa thành một hàm
- Code ngắn gọn hơn, dễ bảo trì hơn

**Kỹ năng giải quyết vấn đề:**

- Phân tích điểm giống và khác nhau
- Tìm cách biến đổi toán học để thống nhất logic
- Sử dụng điều kiện (if) để phân biệt trường hợp


### Ghi chú thêm

**Về phép nhân với -1:**

- Là kỹ thuật toán học cơ bản nhưng hữu ích
- Giúp code gọn gàng hơn so với if-else dài dòng
- Có thể áp dụng trong nhiều bài toán khác

**Về tên biến:**

- Nên đặt tên mô tả rõ chức năng
- Tránh trùng tên với biến global
- IDE sẽ cảnh báo nếu có vấn đề

**Về string formatting:**

- F-string cho phép nhúng biến và biểu thức
- Có thể kết hợp biến với text cố định
- Rất linh hoạt cho việc tạo output động

***

**Liên kết:** [[Caesar Cipher]], [[Decrypt Function]], [[Encrypt Function]], [[DRY Principle]], [[Modulo with Negative Numbers]], [[Shadowing]], [[f-string]], [[Conditional Statements]], [[Mathematical Operations]], [[Code Optimization]]

