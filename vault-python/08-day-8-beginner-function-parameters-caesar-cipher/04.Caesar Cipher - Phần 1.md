

## Caesar Cipher - Phần 1: Xây dựng hàm mã hóa

### Giới thiệu dự án

Caesar Cipher là phương pháp mã hóa văn bản cổ xưa được sử dụng từ thời Julius Caesar để bảo mật các thông điệp quân sự quan trọng.

**Nguyên lý hoạt động:**

- Mỗi chữ cái trong bảng chữ cái được dịch chuyển (shift) một số vị trí xác định trước
- Người gửi và người nhận thống nhất về shift number (số dịch chuyển)
- Ví dụ với shift = 3: A → D, B → E, C → F, v.v.


### Minh họa cơ chế shift

**Công cụ mã hóa cổ điển:**
Người xưa sử dụng đĩa quay (dial) để mã hóa:

- Bảng chữ cái trên và bảng chữ cái dưới được căn chỉnh
- Xoay đĩa để tạo độ lệch (shift)
- Ví dụ: shift = 0 → A căn với A; shift = 3 → A căn với D

**Ví dụ cụ thể:**

- Từ gốc: "hello"
- Shift: 3
- Kết quả: h→k, e→h, l→o, l→o, o→r = "khoor"


### Mục tiêu bài học

Xây dựng chương trình Caesar Cipher có hai chức năng:

- **Encode:** Mã hóa văn bản thành chuỗi ký tự bí mật
- **Decode:** Giải mã chuỗi ký tự về văn bản gốc


### Công cụ quan trọng: Hàm index()

Hàm `index()` giúp tìm vị trí của một phần tử trong danh sách (list).

**Cú pháp:**

```python
list_name.index(item)
```

**Ví dụ minh họa:**

```python
fruits = ["apple", "pear", "orange"]

# Tìm vị trí của "pear"
position = fruits.index("pear")
print(position)  # Output: 1

# Giải thích:
# apple: vị trí 0
# pear: vị trí 1
# orange: vị trí 2
```


### Phân tích bài toán

**Code khởi tạo có sẵn:**

```python
alphabet = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 
            'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']

direction = input("Type 'encode' to encrypt, type 'decode' to decrypt:\n")
text = input("Type your message:\n").lower()
shift = int(input("Type the shift number:\n"))
```

**Các bước thực hiện (4 To-dos):**

**To-do 1:** Tạo hàm `encrypt()` nhận hai tham số
**To-do 2:** Dịch chuyển từng ký tự và in kết quả
**To-do 3:** Gọi hàm với input từ người dùng
**To-do 4:** Xử lý trường hợp vượt quá phạm vi bảng chữ cái

### Giải pháp chi tiết

**Bước 1: Tạo hàm encrypt()**

```python
def encrypt(original_text, shift_amount):
    cipher_text = ""
    
    for letter in original_text:
        # Tìm vị trí hiện tại của chữ cái
        position = alphabet.index(letter)
        
        # Tính vị trí sau khi shift
        shifted_position = position + shift_amount
        
        # Lấy chữ cái mới tại vị trí đã shift
        new_letter = alphabet[shifted_position]
        
        # Thêm vào kết quả
        cipher_text += new_letter
    
    print(f"Here is the encoded result: {cipher_text}")
```

**Giải thích logic:**

Với ví dụ `original_text = "hello"` và `shift_amount = 2`:

1. **Vòng lặp chữ cái đầu tiên (h):**
    - `position = alphabet.index('h')` → 7
    - `shifted_position = 7 + 2` → 9
    - `new_letter = alphabet[9]` → 'j'
    - `cipher_text = "" + "j"` → "j"
2. **Vòng lặp chữ cái thứ hai (e):**
    - `position = 4`
    - `shifted_position = 6`
    - `new_letter = 'g'`
    - `cipher_text = "j" + "g"` → "jg"
3. **Tiếp tục cho các chữ cái còn lại...**

**Bước 2: Gọi hàm**

```python
encrypt(original_text=text, shift_amount=shift)
```


### Xử lý trường hợp đặc biệt: Index Out of Range

**Vấn đề:**
Khi mã hóa chữ 'z' với shift = 9:

- Vị trí của 'z': 25
- Vị trí sau shift: 25 + 9 = 34
- Lỗi: `IndexError: list index out of range` (alphabet chỉ có 26 phần tử từ 0-25)

**Giải pháp: Sử dụng toán tử Modulo (%)**

Toán tử modulo trả về phần dư của phép chia, giúp "quay vòng" về đầu bảng chữ cái.

**Cách hoạt động của modulo:**

```python
# Ví dụ minh họa
4 % 25 = 4      # 4 không chia hết cho 25, phần dư là 4
34 % 26 = 8     # 34 = 26 × 1 + 8, phần dư là 8
50 % 26 = 24    # 50 = 26 × 1 + 24, phần dư là 24
```

**Áp dụng vào code:**

```python
def encrypt(original_text, shift_amount):
    cipher_text = ""
    
    for letter in original_text:
        position = alphabet.index(letter)
        shifted_position = position + shift_amount
        
        # Sử dụng modulo để đảm bảo vị trí luôn trong phạm vi 0-25
        shifted_position %= len(alphabet)
        
        new_letter = alphabet[shifted_position]
        cipher_text += new_letter
    
    print(f"Here is the encoded result: {cipher_text}")
```

**Cú pháp rút gọn:**

```python
# Thay vì:
shifted_position = shifted_position % len(alphabet)

# Có thể viết:
shifted_position %= len(alphabet)
```

**Kiểm tra với ví dụ 'z' shift 9:**

- Vị trí 'z': 25
- Vị trí sau shift: 25 + 9 = 34
- Sau modulo: 34 % 26 = 8
- Chữ cái tại vị trí 8: 'i'
- Kết quả: z → quay vòng → a, b, c, d, e, f, g, h, i ✓


### Test và kết quả

**Test case 1:**

```
Input: encode
Message: hello
Shift: 2
Output: Here is the encoded result: jgnnq
```

**Test case 2:**

```
Input: encode
Message: z
Shift: 9
Output: Here is the encoded result: i
```


### Lưu ý quan trọng

**Về biến accumulator (cipher_text):**

- Phải khởi tạo NGOÀI vòng lặp: `cipher_text = ""`
- Nếu khởi tạo bên trong vòng lặp → giá trị bị reset mỗi lần lặp
- Sử dụng `+=` để nối chuỗi liên tục

**Về việc debug:**

- Nên thêm `print()` ở các bước trung gian để theo dõi giá trị
- Giúp hiểu rõ logic và phát hiện lỗi sớm

**Về modulo:**

- Có nhiều cách giải quyết vấn đề index out of range
- Modulo là cách ngắn gọn và hiệu quả nhất
- Nếu khó hiểu, hãy thử với các số cụ thể để nắm bắt logic


### Kết luận phần 1

Bạn đã hoàn thành:

- Hiểu nguyên lý Caesar Cipher
- Xây dựng hàm mã hóa hoàn chỉnh
- Xử lý edge case với modulo
- Có chương trình mã hóa thông điệp hoạt động được

**Phần tiếp theo:** Xây dựng chức năng giải mã (decode) và kết hợp hai chức năng encode/decode vào một chương trình hoàn chỉnh.

***

**Liên kết:** [[Caesar Cipher]], [[Encryption]], [[Functions]], [[Parameters]], [[for loop]], [[index()]], [[Modulo Operator]], [[List]], [[String Concatenation]], [[IndexError]], [[len()]]

