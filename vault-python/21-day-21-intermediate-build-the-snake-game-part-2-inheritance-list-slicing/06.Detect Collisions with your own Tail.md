

## Ph√°t Hi·ªán Va Ch·∫°m V·ªõi Th√¢n R·∫Øn - B∆∞·ªõc 7 (Ho√†n t·∫•t)

### M·ª•c ti√™u cu·ªëi c√πng

Ph√°t hi·ªán khi ƒë·∫ßu r·∫Øn ch·∫°m v√†o b·∫•t k·ª≥ ph·∫ßn n√†o c·ªßa th√¢n ƒë·ªÉ:

- K·∫øt th√∫c game khi r·∫Øn t·ª± c·∫Øn m√¨nh
- TƒÉng ƒë·ªô kh√≥ khi r·∫Øn c√†ng d√†i
- Ho√†n thi·ªán to√†n b·ªô game Snake


### TƒÉng chi·ªÅu d√†i r·∫Øn khi ƒÉn food

Tr∆∞·ªõc khi ph√°t hi·ªán tail collision, c·∫ßn l√†m r·∫Øn tƒÉng chi·ªÅu d√†i m·ªói khi ƒÉn food.

#### Th√™m methods v√†o Snake Class

```python
class Snake:
    
    def add_segment(self, position):
        segment = Turtle("square")
        segment.color("white")
        segment.penup()
        segment.goto(position)
        self.segments.append(segment)
    
    def create_snake(self):
        for position in STARTING_POSITIONS:
            self.add_segment(position)
    
    def extend(self):
        self.add_segment(self.segments[-1].position())
```

**Refactoring create_snake():**

- T√°ch logic t·∫°o segment th√†nh method ri√™ng `add_segment()`
- `create_snake()` g·ªçi `add_segment()` cho m·ªói v·ªã tr√≠
- Code g·ªçn g√†ng, t√°i s·ª≠ d·ª•ng ƒë∆∞·ª£c

**Method add_segment(position):**

- T·∫°o m·ªôt segment m·ªõi
- ƒê·∫∑t segment t·∫°i v·ªã tr√≠ ƒë∆∞·ª£c truy·ªÅn v√†o
- Th√™m segment v√†o list `self.segments`

**Method extend():**

- G·ªçi `add_segment()` v·ªõi v·ªã tr√≠ c·ªßa segment cu·ªëi c√πng
- Segment m·ªõi xu·∫•t hi·ªán c√πng v·ªã tr√≠ v·ªõi segment cu·ªëi
- Khi r·∫Øn di chuy·ªÉn, segment m·ªõi s·∫Ω "t√°ch ra"


### List Indexing v·ªõi s·ªë √¢m

```python
self.segments[-1]  # L·∫•y ph·∫ßn t·ª≠ cu·ªëi c√πng
```

**C√°ch ho·∫°t ƒë·ªông:**

```python
segments = [seg0, seg1, seg2, seg3, seg4]

segments[0]   # seg0 (ƒë·∫ßu ti√™n)
segments[-1]  # seg4 (cu·ªëi c√πng)
segments[-2]  # seg3 (th·ª© 2 t·ª´ cu·ªëi)
segments[-3]  # seg2 (th·ª© 3 t·ª´ cu·ªëi)
```

**L·ª£i √≠ch:**

- Kh√¥ng c·∫ßn bi·∫øt ƒë·ªô d√†i list
- Lu√¥n l·∫•y ƒë∆∞·ª£c ph·∫ßn t·ª≠ cu·ªëi
- Code linh ho·∫°t khi list thay ƒë·ªïi k√≠ch th∆∞·ªõc


### Method position() c·ªßa Turtle

```python
turtle.position()  # Tr·∫£ v·ªÅ tuple (x, y)
```

**V√≠ d·ª•:**

```python
last_segment = self.segments[-1]
pos = last_segment.position()  # V√≠ d·ª•: (100.0, 50.0)
```

**K·∫øt h·ª£p v·ªõi add_segment:**

```python
self.add_segment(self.segments[-1].position())
# T·∫°o segment m·ªõi t·∫°i v·ªã tr√≠ c·ªßa segment cu·ªëi
```


### G·ªçi extend() trong main.py

```python
# Detect collision with food
if snake.head.distance(food) < 15:
    food.refresh()
    scoreboard.increase_score()
    snake.extend()  # Th√™m segment m·ªõi
```

**K·∫øt qu·∫£:**

- M·ªói l·∫ßn ƒÉn food ‚Üí R·∫Øn d√†i th√™m 1 segment
- Segment m·ªõi xu·∫•t hi·ªán ·ªü v·ªã tr√≠ ƒëu√¥i c≈©
- R·∫Øn li√™n t·ª•c tƒÉng chi·ªÅu d√†i


### Ph√°t hi·ªán Tail Collision

#### Logic c∆° b·∫£n

```python
# Detect collision with tail
for segment in snake.segments:
    if snake.head.distance(segment) < 10:
        game_is_on = False
        scoreboard.game_over()
```

**√ù t∆∞·ªüng:**

- Loop qua t·∫•t c·∫£ segments trong r·∫Øn
- Ki·ªÉm tra kho·∫£ng c√°ch t·ª´ head ƒë·∫øn m·ªói segment
- N·∫øu kho·∫£ng c√°ch < 10 pixels ‚Üí Va ch·∫°m


### V·∫•n ƒë·ªÅ: Head c≈©ng n·∫±m trong segments

**Bug x·∫£y ra:**

- `snake.segments[0]` ch√≠nh l√† `snake.head`
- Head so s√°nh v·ªõi ch√≠nh n√≥ ‚Üí Distance = 0
- Game over ngay l·∫≠p t·ª©c!

**Minh h·ªça:**

```python
for segment in snake.segments:  # [head, seg1, seg2, ...]
    # Iteration 1: segment = head
    if snake.head.distance(segment) < 10:  # 0 < 10 ‚Üí True!
        game_is_on = False  # Game over ngay!
```


### Gi·∫£i ph√°p: B·ªè qua Head

```python
# Detect collision with tail
for segment in snake.segments:
    if segment == snake.head:
        pass  # B·ªè qua head
    elif snake.head.distance(segment) < 10:
        game_is_on = False
        scoreboard.game_over()
```

**C∆° ch·∫ø:**

1. Loop qua m·ªói segment
2. Ki·ªÉm tra: segment n√†y c√≥ ph·∫£i head kh√¥ng?
3. N·∫øu l√† head ‚Üí `pass` (b·ªè qua)
4. N·∫øu kh√¥ng ph·∫£i head ‚Üí Ki·ªÉm tra distance
5. Distance < 10 ‚Üí Game over

**T·∫°i sao d√πng elif:**

- `if` ki·ªÉm tra xem c√≥ ph·∫£i head kh√¥ng
- `elif` ch·ªâ ch·∫°y khi NOT head
- Logic r√µ r√†ng, tr√°nh l·ªói


### S∆° ƒë·ªì lu·ªìng Tail Collision Detection

```mermaid
graph TD
    A[Loop qua segments] --> B{segment == head?}
    B -->|Yes| C[Pass, b·ªè qua]
    B -->|No| D{distance < 10?}
    D -->|Yes| E[game_is_on = False]
    D -->|No| F[Ti·∫øp t·ª•c loop]
    E --> G[scoreboard.game_over]
    C --> F
    F --> H{C√≤n segment?}
    H -->|Yes| A
    H -->|No| I[K·∫øt th√∫c ki·ªÉm tra]
```


### Code ho√†n ch·ªânh snake.py

```python
from turtle import Turtle

STARTING_POSITIONS = [(0, 0), (-20, 0), (-40, 0)]
MOVE_DISTANCE = 20
UP = 90
DOWN = 270
LEFT = 180
RIGHT = 0

class Snake:
    
    def __init__(self):
        self.segments = []
        self.create_snake()
        self.head = self.segments[0]
    
    def create_snake(self):
        for position in STARTING_POSITIONS:
            self.add_segment(position)
    
    def add_segment(self, position):
        segment = Turtle("square")
        segment.color("white")
        segment.penup()
        segment.goto(position)
        self.segments.append(segment)
    
    def extend(self):
        self.add_segment(self.segments[-1].position())
    
    def move(self):
        for seg_num in range(len(self.segments) - 1, 0, -1):
            new_x = self.segments[seg_num - 1].xcor()
            new_y = self.segments[seg_num - 1].ycor()
            self.segments[seg_num].goto(new_x, new_y)
        self.head.forward(MOVE_DISTANCE)
    
    def up(self):
        if self.head.heading() != DOWN:
            self.head.setheading(UP)
    
    def down(self):
        if self.head.heading() != UP:
            self.head.setheading(DOWN)
    
    def left(self):
        if self.head.heading() != RIGHT:
            self.head.setheading(LEFT)
    
    def right(self):
        if self.head.heading() != LEFT:
            self.head.setheading(RIGHT)
```


### Code ho√†n ch·ªânh main.py

```python
from turtle import Screen
from snake import Snake
from food import Food
from scoreboard import Scoreboard
import time

screen = Screen()
screen.setup(width=600, height=600)
screen.bgcolor("black")
screen.title("My Snake Game")
screen.tracer(0)

snake = Snake()
food = Food()
scoreboard = Scoreboard()

screen.listen()
screen.onkey(snake.up, "Up")
screen.onkey(snake.down, "Down")
screen.onkey(snake.left, "Left")
screen.onkey(snake.right, "Right")

game_is_on = True
while game_is_on:
    screen.update()
    time.sleep(0.1)
    snake.move()
    
    # Detect collision with food
    if snake.head.distance(food) < 15:
        food.refresh()
        scoreboard.increase_score()
        snake.extend()
    
    # Detect collision with wall
    if snake.head.xcor() > 280 or snake.head.xcor() < -280 or snake.head.ycor() > 280 or snake.head.ycor() < -280:
        game_is_on = False
        scoreboard.game_over()
    
    # Detect collision with tail
    for segment in snake.segments:
        if segment == snake.head:
            pass
        elif snake.head.distance(segment) < 10:
            game_is_on = False
            scoreboard.game_over()

screen.exitonclick()
```


### T·∫°i sao ch·ªçn distance < 10?

**K√≠ch th∆∞·ªõc segments:**

- M·ªói segment: 20x20 pixels
- Center ƒë·∫øn center: C·∫ßn kho·∫£ng c√°ch > 0 ƒë·ªÉ collision

**Testing:**

- Distance = 10 cho c·∫£m gi√°c collision t·ª± nhi√™n
- Distance = 5 qu√° kh√≥ (ph·∫£i tr√∫ng ch√≠nh x√°c)
- Distance = 15 qu√° d·ªÖ (collision t·ª´ xa)

**So s√°nh:**

```python
# Qu√° kh√≥
if snake.head.distance(segment) < 5:

# V·ª´a ph·∫£i - Recommended
if snake.head.distance(segment) < 10:

# Qu√° d·ªÖ
if snake.head.distance(segment) < 15:
```


### C√°ch vi·∫øt ng·∫Øn g·ªçn h∆°n (s·∫Ω h·ªçc ·ªü b√†i sau)

Transcript mention v·ªÅ **slicing** - k·ªπ thu·∫≠t s·∫Ω c·∫£i thi·ªán code:

```python
# C√°ch hi·ªán t·∫°i (verbose)
for segment in snake.segments:
    if segment == snake.head:
        pass
    elif snake.head.distance(segment) < 10:
        game_is_on = False
        scoreboard.game_over()

# C√°ch d√πng slicing (s·∫Ω h·ªçc)
for segment in snake.segments[1:]:  # B·ªè qua segment ƒë·∫ßu (head)
    if snake.head.distance(segment) < 10:
        game_is_on = False
        scoreboard.game_over()
```


### Testing Snake Game ho√†n ch·ªânh

**C√°c t√¨nh hu·ªëng c·∫ßn test:**

1. **ƒÇn food:**
    - R·∫Øn tƒÉng chi·ªÅu d√†i ‚úì
    - ƒêi·ªÉm s·ªë tƒÉng ‚úì
    - Food xu·∫•t hi·ªán v·ªã tr√≠ m·ªõi ‚úì
2. **Va ch·∫°m t∆∞·ªùng:**
    - C·∫°nh tr√°i ‚Üí Game over ‚úì
    - C·∫°nh ph·∫£i ‚Üí Game over ‚úì
    - C·∫°nh tr√™n ‚Üí Game over ‚úì
    - C·∫°nh d∆∞·ªõi ‚Üí Game over ‚úì
3. **Va ch·∫°m th√¢n:**
    - R·∫Øn ng·∫Øn (3 segments) ‚Üí Kh√¥ng th·ªÉ t·ª± c·∫Øn ‚úì
    - R·∫Øn d√†i ‚Üí C√≥ th·ªÉ t·ª± c·∫Øn ‚Üí Game over ‚úì
4. **ƒêi·ªÅu khi·ªÉn:**
    - Ph√≠m m≈©i t√™n ho·∫°t ƒë·ªông t·ªët ‚úì
    - Kh√¥ng th·ªÉ quay 180¬∞ ng∆∞·ª£c ‚úì

### T·ªïng k·∫øt 7 b∆∞·ªõc ƒë√£ ho√†n th√†nh

1. ‚úÖ T·∫°o th√¢n r·∫Øn (3 segments)
2. ‚úÖ Di chuy·ªÉn r·∫Øn t·ª± ƒë·ªông
3. ‚úÖ ƒêi·ªÅu khi·ªÉn b·∫±ng b√†n ph√≠m
4. ‚úÖ Ph√°t hi·ªán va ch·∫°m v·ªõi food
5. ‚úÖ T·∫°o scoreboard
6. ‚úÖ Ph√°t hi·ªán va ch·∫°m v·ªõi t∆∞·ªùng
7. ‚úÖ Ph√°t hi·ªán va ch·∫°m v·ªõi th√¢n r·∫Øn

üéâ **GAME SNAKE HO√ÄN CH·ªàNH!**

### C·∫•u tr√∫c project cu·ªëi c√πng

```
snake_game/
‚îú‚îÄ‚îÄ main.py           # Game loop v√† logic ch√≠nh
‚îú‚îÄ‚îÄ snake.py          # Snake class
‚îú‚îÄ‚îÄ food.py           # Food class
‚îî‚îÄ‚îÄ scoreboard.py     # Scoreboard class
```

**Nguy√™n t·∫Øc t·ªï ch·ª©c:**

- M·ªói class trong file ri√™ng
- Single Responsibility Principle
- Code modular, d·ªÖ maintain
- R√µ r√†ng, d·ªÖ m·ªü r·ªông


### Ki·∫øn th·ª©c ƒë√£ √°p d·ª•ng

**Object Oriented Programming:**

- Class inheritance (Food, Scoreboard t·ª´ Turtle)
- Refactoring code
- Method organization

**Python Techniques:**

- List indexing v·ªõi s·ªë √¢m
- For loop v·ªõi conditional
- Pass statement
- Position tracking

**Game Development:**

- Collision detection (food, wall, tail)
- Game state management
- Score tracking
- User input handling
- Animation control

**Turtle Graphics:**

- Multiple turtle objects
- Writing text
- Coordinate system
- Distance calculation


### Kh√°i ni·ªám s·∫Ω h·ªçc ti·∫øp (Slicing)

**Preview:**

```python
# Thay v√¨
for segment in snake.segments:
    if segment == snake.head:
        pass
    elif condition:
        # do something

# C√≥ th·ªÉ vi·∫øt
for segment in snake.segments[1:]:  # Slice t·ª´ index 1 tr·ªü ƒëi
    if condition:
        # do something
```

**Slicing cho ph√©p:**

- L·∫•y m·ªôt ph·∫ßn c·ªßa list
- B·ªè qua c√°c ph·∫ßn t·ª≠ kh√¥ng c·∫ßn
- Code ng·∫Øn g·ªçn v√† r√µ r√†ng h∆°n


### M·ªü r·ªông game (Ideas)

**T√≠nh nƒÉng c√≥ th·ªÉ th√™m:**

- High score l∆∞u v√†o file
- T·ªëc ƒë·ªô tƒÉng d·∫ßn theo ƒëi·ªÉm
- Nhi·ªÅu level kh√°c nhau
- Power-ups ƒë·∫∑c bi·ªát
- Ch∆∞·ªõng ng·∫°i v·∫≠t tr√™n m√†n h√¨nh
- √Çm thanh hi·ªáu ·ª©ng
- Menu start/pause/restart


### Debugging tips cu·ªëi c√πng

**R·∫Øn kh√¥ng tƒÉng chi·ªÅu d√†i:**

```python
# Ki·ªÉm tra extend() c√≥ ƒë∆∞·ª£c g·ªçi kh√¥ng
print("Snake extended!")  # Trong extend()
```

**Game over ngay l·∫≠p t·ª©c:**

```python
# ƒê·∫£m b·∫£o skip head
if segment == snake.head:
    pass  # Ph·∫£i c√≥ d√≤ng n√†y
```

**Collision kh√¥ng ch√≠nh x√°c:**

```python
# ƒêi·ªÅu ch·ªânh distance threshold
if snake.head.distance(segment) < 10:  # Th·ª≠ 8, 12...
```


### Ch√∫c m·ª´ng! üéâ

B·∫°n ƒë√£ ho√†n th√†nh Snake Game v·ªõi:

- 7 b∆∞·ªõc ph√°t tri·ªÉn r√µ r√†ng
- 3 classes ƒë∆∞·ª£c t·ªï ch·ª©c t·ªët
- ƒê·∫ßy ƒë·ªß game mechanics
- Clean v√† maintainable code

**B√†i t·∫≠p th·ª±c h√†nh:**

- Ch∆°i game v√† ƒë·∫°t high score
- Th·ª≠ ƒëi·ªÅu ch·ªânh speed, boundary
- Th√™m features m·ªõi
- Share v·ªõi b·∫°n b√®!

**Li√™n k·∫øt:** [[List Negative Indexing]], [[Position Method]], [[Pass Statement]], [[Tail Collision]], [[Extend Method]], [[Add Segment]], [[Game Completion]], [[Python Slicing]], [[Code Refactoring]], [[Final Testing]]

